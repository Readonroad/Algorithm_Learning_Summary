## 正则表达式
用来匹配字符串，用一种描述性的语言来给字符串定义一个规则，符合规则的字符串，就认为是匹配的。

### 特殊符号
```
特殊符号| 含义
--- |---
.    | 匹配任意字符，除了换行符
*    | 任意个字符，包括0个
+    | 至少一个字符
？   | 0个或1个字符
^    | 表示行开头
$    | 表示行结尾
{m}  | 匹配m个字符
{m,n}| 表示 n-m 个字符
\d   | 匹配任意数字
\w   | 匹配任意字母或数字 
\    | 对于特殊字符，要转义，如'\-'
\s   | 匹配一个空格，包括tab等空白符
[]   | 表示一个氛围，更精确地匹配
A|B  | 匹配A或者B
```
### re模块
re模块，包含所有正则表达式的功能，由于python的字符串本身也用‘\'转义，因此要特别注意。可以在字符串前面加上r,就不用考虑转义的问题了
```python
import re
re.match(r'正则表达式',输入) #若匹配，则返回一个Match对象，否则返回None
if re.match(r'正则表达式',输入):
    print('ok')
else :
    print('error')
```
### re用途
* 切分字符串
```
str.split(r'正则表达式')
re.split(r'正则表达式', 字符串)
```
* 分组,用（）表示要提取的分组
```python 
# '^(\d{3})-(\d{3,8})$'分别定义了两个组
m = re.match(r'^(\d{3})-(\d{3,8})$','010-12345')
m.group(0)     # '010'
m.group(1)     # '12345'
m.groups()     # ('010', '12345') 元祖
```
对于re.match()返回的Match对应，可以用group()方法提取出子串,group(0)对应的是原始字符串，group(1)、group(2)...表示第1,2,...个子串。

* 贪婪匹配
```python
#正则匹配默认是贪婪匹配，匹配尽可能多的字符
re.match(r'^(\d+)(0*)$','102300').groups()
#输出为（'102300'，''）
```
* 非贪婪匹配
```python
#通过加？,可以采用非贪婪匹配
re.match(r'^(\d+?)(0*)$','102300').groups()
#输出为（‘1023’，‘00’）
```
